

# Задания {tasks}

```{r include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

##Вектор

Посчитайте логарифм от 8912162342 по основанию 6 и запишите результат в переменную V1.

```{r}
V1 <- log(8912162342)
V1
```

Теперь экспоненту (функция exp()) от натурального логарифма от 1. Её запишите в V2.

> Что, забыли, как считать натуральный логарифм? Он считается автоматически, если не указывать в функции основание.

```{r}
V2 <- exp(1)
V2
```

Давайте теперь сделаем вектор из этих двух переменных. Сделайте вектор из переменных V1 и V2. Назовите его V3.

```{r}
V3 <- c(V1, V2)
V3
```

Ладно, это было нетрудно. А теперь сделайте вектор V4, в котором соедините V3, а также _названия переменных_ V1 и V2 в формате character.

```{r}
V4 <- c(V3, "V1", "V2")
V4
```

Создайте вектор от 1 до 20

```{r}
1:20
```

Создайте вектор от 20 до 1

```{r}
20:1
```

Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!

```{r}
c(1:20, 19:1)
```

Создайте вектор 2, 4, 6,  ... , 18, 20

```{r}
seq(2,20, 2)
```

Создайте вектор 2, 4, 6,  ... , 18, 20 как минимум 2 другими способами
> Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части.

```{r}
(1:20)[c(F,T)]
#(1:10)*2
```


# Матрицы

- Создайте матрицу 4х4, состоящую из единиц.

```{r}
matrix(rep(1, 16), ncol = 4)
```


- Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную `tab`:

```{r}
tab <- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9)
tab

#Еще
#outer(1:9, 1:9, "*")
#1:9 %o% 1:9
```

 адания 
## Создание функций

- Создайте функцию `century()`, которая превращает год в век. Возможно, понадобится вспомнить, [как года переводятся в века](https://ru.wikipedia.org/wiki/Век). 

```{r}
century <- function(x) floor(x/100)+1 
```

```{r}
century(100)
```
- А теперь сделайте функцию `century_roman()`, которая переводит год в век, записанный римскими цифрами!

> Здесь нужно просто немного погуглить

```{r}
century_roman <- function(x) as.roman(floor(x/100)+1)
```

```{r}
century_roman(2099)
```

- Напишите функцию `is_prime()`, которая проверяет, является ли число простым.

> Здесь может понадобиться оператор для получения остатка от деления: `%%`. Еще может пригодиться функция `any()` - она возвращает `TRUE`, если в векторе есть хотя бы один `TRUE`

```{r}
is_prime <- function(x) !any(x%%(2:(x-1)) == 0)
``` 

```{r}
is_prime(13)
```

## Семейство apply() 

- Посчитайте, в какой из 5 книг больше всего персонажей.

```{r}
apply(got[, 9:13], 2, sum)

#Без apply():

#colSums(got[, 9:13])

#Еще:

#sapply(got[,9:13], sum)
```

- Сделайте датафрейм `heroes` с персонажами, которые присутствовали во всех книгах.

```{r}
heroes <- got[apply(got[, 9:13], 1, sum) == 5, ]

heroes

#Еще

#heroes <- got[rowSums(got[, 9:13]) == 5, ]
```


- Есть список `spisok`:

```{r, echo = TRUE}
spisok <- list(1:5, 0:20, 4:24, 6:3, 6:25)
```

- Посчитайте сумму каждого вектора.

```{r}
sapply(spisok, sum)
```

- А теперь длину.

```{r}
sapply(spisok, length)
```

- Напишите функцию `max_item()`, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.

```{r}
max_item <- function (x) spisok[[which.max(sapply(x, length))]]
```

- Теперь мы сделаем сложный список:

```{r}
large_spisok <- list(1:3, 3:40, spisok)
```

- Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри

> Для этого может понадобиться функция `rapply()`: **recursive lapply**

```{r}
rapply(large_spisok, length, how = "list")
```

##Работа с текстом

Дан строковый вектор:

```{r}
s <- c("Я", "выучу", "R", "за", "май!")
```

Соедините вектор в одно строковое значение `ch`

```{r}
ch <- paste(s, collapse = " ")
ch
```

Подсчитайте количество знаков в `ch`

```{r}
nchar(ch)
```

Следующее задание: вырезать Замая

```{r}
substr(ch, 11, 16)
```

Превратите `ch` обратно в вектор, значения которого - отдельные слова:

```{r}
strsplit(ch, " ")[[1]]
```

Создайте дополнительную колонку в `got` под названием `info`, в которой будет написано: 
"ИМЯ_ПЕРСОНАЖА from House ЕГО_ДОМ is dead/alive" в зависимости от его статуса

```{r}
got$info <- paste(got$Name, "from House", got$Houses, "is", got$Is.Alive)
got$info <- sprintf("%s from House %s is %s", got$Name, got$Houses, got$Is.Alive)
head(got$info)
```



Создайте функцию `is_anagram()`, которая будет выдавать `TRUE` если одно слово является анаграммой другого.

```{r}
a <- "tree"
b <- "erte"

is_anagram <- function(a, b) paste(sort(strsplit(a, "")[[1]]), collapse = "") == paste(sort(strsplit(b, "")[[1]]), collapse = "")
```

Проверьте, работает ли функция, на двух векторах:

```{r}
a <- c("спаниель", "капюшон", "state")
b <- c("апельсин", "парашют", "taste")
```

> Нужно либо векторизовать функцию (сделать так, чтобы она могла принимать вектора на входе), либо использовать mapply(). Есть простой и хитрый способ векторизовать функцию - Vectorize(). Постарайтесь все-таки не использовать for, пожалуйста.

```{r}
mapply(is_anagram, a, b)
is_anagram_v <- function(a, b) {
  sapply(sapply(sapply(a,strsplit, ""), sort), paste, collapse = "") == sapply(sapply(sapply(b,strsplit, ""), sort), paste, collapse = "")
}
```

##Решейпинг

Допустим, у вас есть следующий `data.table`:

```{r}
iq <- data.table(id = 1:3, iq_before = c(98, 106, 102), iq_after = c(103, 105, 103))
```

Превратите широкий iq в длинный iq_long с колонками `id`, `time`, `IQ`

```{r}
iq_long <- melt(iq, id.vars = 'id', variable.name = "time", value.name = "IQ")
iq_long
```

В колонке `time` должно быть значение `before` или `after`

```{r}
iq_long[, time := gsub("iq_", "", time)]
iq_long
```

А теперь обратно `iq_long` в широкий формат:

```{r}
dcast(iq_long, ... ~ time)
```

